# -*- coding: utf-8 -*-
"""minimax.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jC-HbgC0biurEb57Bkej5-4QRjwSMh0S

# Ćwiczenie 3

Celem ćwiczenia jest imlementacja metody [Minimax z obcinaniem alpha-beta](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning) do gry Connect Four (czwórki).

W trakcie ćwiczenia można skorzystać z reposytorium z implementacją gry [Connect Four udostępnionym przez Jakuba Łyskawę](https://github.com/lychanl/two-player-games). Ewentualnie, można zaimplementować samemu grę Connect Four (ale, tak aby rozwiązanie miało ten sam interfejs co podany poniżej).

Implementację Minimax należy przetestować używając różną głębokość przeszukiwania. Implementacja Solvera musi zapewniać interfejs jak poniżej, ale można dodać dowolne metody prywatne oraz klasy wspomagające (jeżeli będą potrzebne).

Punktacja:
- Działająca metoda Minimax - **2 pkt**
- Działająca metoda Minimax z obcinaniem alpha-beta - **1.5 pkt**
- Analiza jakości solvera w zależności od głębokości przeszukiwania **1.5pkt**
    - można zaimplementować w tym celu wizualizację rozgrywki dwóch agentów, bądź kilka przykładów 'z ręki'
- Jakość kodu **2pkt**

Aby importowanie elementów z poniższej komórki działało należy umieścić tego notebooka w tym samym folderze co paczkę `two_player_games`:
```
├── LICENSE
├── README.md
├── minimax.ipynb # HERE
├── test
│   ├── __init__.py
│   ├── test_connect_four.py
│   ├── test_dots_and_boxes.py
│   └── test_pick.py
└── two_player_games
    ├── __init__.py
    ├── games
    │   ├── connect_four.py
    │   └── dots_and_boxes.py
    ├── move.py
    ├── player.py
    └── state.py
```
"""

from typing import Tuple, List

from two_player_games.player import Player
from two_player_games.games.connect_four import ConnectFour, ConnectFourMove
import math
import copy
import random


"""Wielkość planszy"""

ROW_COUNT = 6
COLUMN_COUNT = 7

class MinMaxSolver:

    def __init__(self, game: ConnectFour):
        self.game = game
        self.state = self.game.state


    def evaluate_position(self, player: Player, other: Player)->float:
        # heurystyka
        heuristic = 0
        for column_id in range(len(self.state.fields)):  # verticals
            for start_row_id in range(len(self.state.fields[column_id])):
                try:
                    if self.state.fields[column_id][start_row_id] == self.state.fields[column_id + 1][start_row_id] == player and (self.state.fields[column_id - 2][start_row_id] == self.state.fields[column_id - 1][start_row_id] == None or self.state.fields[column_id + 2][start_row_id] == self.state.fields[column_id + 3][start_row_id] == None):
                        heuristic += 10
                    if self.state.fields[column_id][start_row_id] == self.state.fields[column_id + 1][start_row_id] == self.state.fields[column_id + 2][start_row_id] == player and (self.state.fields[column_id - 1][start_row_id] == None or self.state.fields[column_id + 3][start_row_id] == None):
                        heuristic += 1000
                    if self.state.fields[column_id] == self.state.fields[column_id + 1][start_row_id] == self.state.fields[column_id + 2][start_row_id] == self.state.fields[column_id + 3][start_row_id] == player:
                        heuristic += 100000
                except IndexError:
                    pass
        for start_column_id in range(len(self.state.fields)):  # horizontals
            for row_id in range(len(self.state.fields[start_column_id])):
                try:
                    if self.state.fields[start_column_id][row_id] == self.state.fields[start_column_id][row_id + 1] == player and (self.state.fields[column_id][start_row_id - 2] == self.state.fields[column_id][start_row_id - 1] == None or self.state.fields[column_id][start_row_id + 2] == self.state.fields[column_id][start_row_id + 3] == None):
                        heuristic += 10
                    if self.state.fields[start_column_id][row_id] == self.state.fields[start_column_id][row_id + 1] == self.state.fields[start_column_id][row_id + 2] == player and (self.state.fields[column_id][start_row_id - 1] == None or self.state.fields[column_id][start_row_id + 3] == None):
                        heuristic += 1000
                    if self.state.fields[start_column_id][row_id] == self.state.fields[start_column_id][row_id + 1] == self.state.fields[start_column_id][row_id + 2] == self.state.fields[start_column_id][row_id + 3] == player:
                        heuristic += 100000
                except IndexError:
                    pass
        for start_column_id in range(len(self.state.fields)):  # diagonals positive
            for start_row_id in range(len(self.state.fields[start_column_id])):
                if start_row_id + 3 <= len(self.state.fields[start_column_id]) and start_column_id + 3 <= len(self.state.fields):
                    try:
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id + 1] == player and (self.state.fields[column_id - 2][start_row_id - 2] == self.state.fields[column_id - 1][start_row_id - 1] == None or self.state.fields[column_id + 2][start_row_id + 2] == self.state.fields[column_id + 3][start_row_id + 3] == None):
                            heuristic += 10
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id + 1] == self.state.fields[start_column_id + 2][start_row_id + 2] == player and (self.state.fields[column_id - 1][start_row_id - 1] == None or self.state.fields[column_id + 3][start_row_id + 3] == None):
                            heuristic += 1000
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id + 1] == self.state.fields[start_column_id + 2][start_row_id + 2] == self.state.fields[start_column_id + 3][start_row_id + 3] == player:
                            heuristic += 100000
                    except IndexError:
                        pass
        for start_column_id in range(len(self.state.fields)):  # diagonals negative
            for start_row_id in range(len(self.state.fields[start_column_id])):
                if start_row_id - 3 >= 0 and start_column_id + 3 <= len(self.state.fields):
                    try:
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id - 1] == player and (self.state.fields[column_id - 2][start_row_id + 2] == self.state.fields[column_id - 1][start_row_id + 1] == None or self.state.fields[column_id + 2][start_row_id - 2] == self.state.fields[column_id + 3][start_row_id - 3] == None):
                            heuristic += 10
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id - 1] == self.state.fields[start_column_id + 2][start_row_id - 2] == player and (self.state.fields[column_id - 1][start_row_id + 1] == None or self.state.fields[column_id + 3][start_row_id - 3] == None):
                            heuristic += 1000
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id - 1] == self.state.fields[start_column_id + 2][start_row_id - 2] == self.state.fields[start_column_id + 3][start_row_id - 3] == player:
                            heuristic += 100000
                    except IndexError:
                        pass
        for column_id in range(len(self.state.fields)):  # verticals
            for start_row_id in range(len(self.state.fields[column_id])):
                try:
                    if self.state.fields[column_id][start_row_id] == self.state.fields[column_id + 1][start_row_id] == other and (self.state.fields[column_id - 2][start_row_id] == self.state.fields[column_id - 1][start_row_id] == None or self.state.fields[column_id + 2][start_row_id] == self.state.fields[column_id + 3][start_row_id] == None):
                        heuristic -= 10
                    if self.state.fields[column_id][start_row_id] == self.state.fields[column_id + 1][start_row_id] == self.state.fields[column_id + 2][start_row_id] == other and (self.state.fields[column_id - 1][start_row_id] == None or self.state.fields[column_id + 3][start_row_id] == None):
                        heuristic -= 1000
                    if self.state.fields[column_id] == self.state.fields[column_id + 1][start_row_id] == self.state.fields[column_id + 2][start_row_id] == self.state.fields[column_id + 3][start_row_id] == other:
                        heuristic -= 100000
                except IndexError:
                    pass
        for start_column_id in range(len(self.state.fields)):  # horizontals
            for row_id in range(len(self.state.fields[start_column_id])):
                try:
                    if self.state.fields[start_column_id][row_id] == self.state.fields[start_column_id][row_id + 1] == other and (self.state.fields[column_id][start_row_id - 2] == self.state.fields[column_id][start_row_id - 1] == None or self.state.fields[column_id][start_row_id + 2] == self.state.fields[column_id][start_row_id + 3] == None):
                        heuristic -= 10
                    if self.state.fields[start_column_id][row_id] == self.state.fields[start_column_id][row_id + 1] == self.state.fields[start_column_id][row_id + 2] == other and (self.state.fields[column_id][start_row_id - 1] == None or self.state.fields[column_id][start_row_id + 3] == None):
                        heuristic -= 1000
                    if self.state.fields[start_column_id][row_id] == self.state.fields[start_column_id][row_id + 1] == self.state.fields[start_column_id][row_id + 2] == self.state.fields[start_column_id][row_id + 3] == other:
                        heuristic -= 100000
                except IndexError:
                    pass
        for start_column_id in range(len(self.state.fields)):  # diagonals positive
            for start_row_id in range(len(self.state.fields[start_column_id])):
                if start_row_id + 3 <= len(self.state.fields[start_column_id]) and start_column_id + 3 <= len(self.state.fields):
                    try:
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id + 1] == other and (self.state.fields[column_id - 2][start_row_id - 2] == self.state.fields[column_id - 1][start_row_id - 1] == None or self.state.fields[column_id + 2][start_row_id + 2] == self.state.fields[column_id + 3][start_row_id + 3] == None):
                            heuristic -= 10
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id + 1] == self.state.fields[start_column_id + 2][start_row_id + 2] == other and (self.state.fields[column_id - 1][start_row_id - 1] == None or self.state.fields[column_id + 3][start_row_id + 3] == None):
                            heuristic -= 1000
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id + 1] == self.state.fields[start_column_id + 2][start_row_id + 2] == self.state.fields[start_column_id + 3][start_row_id + 3] == other:
                            heuristic -= 100000
                    except IndexError:
                        pass
        for start_column_id in range(len(self.state.fields)):  # diagonals negative
            for start_row_id in range(len(self.state.fields[start_column_id])):
                if start_row_id - 3 >= 0 and start_column_id + 3 <= len(self.state.fields):
                    try:
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id - 1] == other and (self.state.fields[column_id - 2][start_row_id + 2] == self.state.fields[column_id - 1][start_row_id + 1] == None or self.state.fields[column_id + 2][start_row_id - 2] == self.state.fields[column_id + 3][start_row_id - 3] == None):
                            heuristic -= 10
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id - 1] == self.state.fields[start_column_id + 2][start_row_id - 2] == other and (self.state.fields[column_id - 1][start_row_id + 1] == None or self.state.fields[column_id + 3][start_row_id - 3] == None):
                            heuristic -= 1000
                        if self.state.fields[start_column_id][start_row_id] == self.state.fields[start_column_id + 1][start_row_id - 1] == self.state.fields[start_column_id + 2][start_row_id - 2] == self.state.fields[start_column_id + 3][start_row_id - 3] == other:
                            heuristic -= 100000
                    except IndexError:
                        pass
        return heuristic

    #def minimax(self, depth, alpha:float, beta:float, is_maximizing_player:bool)-> Tuple[int, float]:
        """Returns column index and score"""
    # def minimax(self, node, depth, is_max) -> Tuple[int, float]:

    #     if is_max:
    #         return self.minimax(node, depth, -math.inf, math.inf, True)
    #     else:
    #         return self.minimax(node, depth, -math.inf, math.inf, False)

        
    def minimax(self,game, depth, alpha:float, beta:float, is_maximizing_player:bool)-> Tuple[int, float]:
        if depth == 0 or len(self._get_valid_locations()) == 0:
            # return None, self.evaluate_position(self.state._current_player, self.state._other_player)
            if is_maximizing_player:
                return None, self.evaluate_position(self.state._current_player, self.state._other_player)
            else:
                return None, -self.evaluate_position(self.state._current_player, self.state._other_player)
        if is_maximizing_player:
            best_score = -math.inf
            best_moves = []
            best_move = None
            for location in self._get_valid_locations():
                temp_game = copy.deepcopy(self.game.state)
                move = ConnectFourMove(location)
                temp_game.make_move(move)
                tmp_move, evaluation = self.minimax(temp_game, depth-1, alpha, beta, is_maximizing_player)
                if evaluation == best_score:
                    move_col = move.column
                    best_moves.append(move_col)
                if evaluation > best_score:
                    best_move = move.column
                    best_moves = [best_move]
                best_score = max(best_score, evaluation)
                alpha = max(alpha, best_score)
                if alpha >= beta:
                    break
            chosen_move = random.choice(best_moves)
            return chosen_move, best_score
        else:
            best_score = math.inf
            best_moves = []
            best_move = None
            for location in self._get_valid_locations():
                temp_game = copy.deepcopy(self.game.state)
                move = ConnectFourMove(location)
                temp_game.make_move(move)
                tmp_move, evaluation = self.minimax(temp_game, depth-1, alpha, beta, is_maximizing_player)
                if evaluation == best_score:
                    move_col = move.column
                    best_moves.append(move_col)
                if evaluation < best_score:
                    best_move = move.column
                    best_moves = [best_move]
                best_score = min(best_score, evaluation)
                beta = min(beta, best_score)
                if alpha >= beta:
                    break
            chosen_move = random.choice(best_moves)
            return chosen_move, best_score
        
        


    def get_best_move(self, game, depth, is_max):
        if is_max:
            move, value = self.minimax(game, depth, -math.inf, math.inf, True)
            best_move = ConnectFourMove(move)
        else:
            move, value = self.minimax(game, depth, -math.inf, math.inf, False)
            best_move = ConnectFourMove(move)
        return best_move
    
  

    def _get_valid_locations(self)->List[int]:
        valid_locations = []
        for column_id in range(len(self.state.fields)):
            if self._is_valid_move(column_id):
                # tmp_move = self.state.make_move(ConnectFourMove(column_id))
                valid_locations.append(column_id)
                # valid_locations.append(tmp_move)
        return valid_locations


    def _is_valid_move(self, col_index:int)->bool:
        for row_val in self.state.fields[col_index]:
            if row_val is None:
                return True
        return False


def main():
    p1 = Player("a")
    p2 = Player("b")
    game = ConnectFour(size=(COLUMN_COUNT, ROW_COUNT), first_player=p1, second_player=p2)
    print(game)
    strategy = MinMaxSolver(game)
    while game.is_finished() is False:
        current_player = game.state.get_current_player()
        if current_player.char == game.second_player.char:
            game.make_move(strategy.get_best_move(game, 4, False))
        if current_player.char == game.first_player.char:
            game.make_move(strategy.get_best_move(game, 4, True))
    
            
        print(game)
    winner = game.get_winner()   
    print(f' THE WINNER IS {winner.char}')

"""Rozgrywka"""
main()
# p1 = Player("a")
# p2 = Player("b")
# game = ConnectFour(size=(COLUMN_COUNT, ROW_COUNT), first_player=p1, second_player=p2)
# strategy = MinMaxSolver(game)
# game.make_move(ConnectFourMove(3))
# game.make_move(ConnectFourMove(4))
# game.make_move(ConnectFourMove(3))
# game.make_move(ConnectFourMove(4))
# game.make_move(strategy.get_best_move(game, 3, True))
# game.make_move(strategy.get_best_move(game, 3, False))
# print(game)





